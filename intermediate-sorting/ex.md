## 목표

- 지금까지 학습한 정렬 알고리즘의 한계 이해
- 합병 정렬 구현
- 빠른 정렬 구현
- 기수 정렬 구현

### 한계

- 지금까지 학습한 정렬 알고리즘은 확장성이 좋지 않습니다.
- 100000개 요소의 배열에 대해 버블 정렬을 시도해 보십시오, 시간이 꽤 걸립니다.
- 대규모 어레이를 보다 신속하게 정렬할 수 있어야 함

### 빠른 정렬

- 시간 복잡성을 O(n)에서 O(n log n)로 개선할 수 있는 정렬 알고리즘 계열이 있다.
- 효율성과 단순성 사이에는 절충점이 있습니다.
- 더 효율적인 알고리즘은 훨씬 덜 단순하고 일반적으로 이해하는 데 더 오랜 시간이 걸린다.

### Merge Sort - 합병 정렬

- 합병과 정렬이라는 두 가지를 결합한 것이다.
- 0 또는 1 요소의 배열이 항상 정렬된다는 사실을 활용합니다.
- 배열을 0 또는 1 요소의 작은 배열로 분해한 다음 새로 정렬된 배열을 구성하는 방식으로 작동합니다.

- How does it work?

[ 8, 3, 5, 4, 7, 6, 1, 2 ]

[ 8, 3, 5, 4 ] [ 7, 6, 1, 2 ]

[ 8, 3 ] [ 5, 4 ] [ 1, 2 ] [ 7, 6 ]

[ 8 ] [ 3 ] [ 5 ] [ 4 ] [ 7 ] [ 6 ] [ 1 ] [ 2 ]

[ 3, 8 ] [ 4, 5 ] [ 6, 7 ] [ 1, 2 ]

[ 3, 4, 5, 8 ] [ 1, 2, 6, 7 ]

[ 1, 2, 3, 4, 5, 6, 7, 8 ]

합병 정렬을 구현하려면 먼저 정렬된 두 배열의 합병을 담당하는 함수를 구현하는 것이 유용합니다.
정렬된 두 배열이 주어지면, 이 도우미 함수는 또한 정렬되고 두 입력 배열의 모든 요소로 구성된 새로운 배열을 생성해야 한다.
이 기능은 O(n + m) 시간 및 O(n + m) 공간에서 실행되어야 하며 전달된 파라미터를 수정해서는 안 됩니다.

| Algorithms     | Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| -------------- | --------------------- | ------------------------ | ---------------------- | ---------------- |
| Merge Sort     | O(n log n)            | O(n log n)               | O(n log n)             | O(n)             |
| Insertion Sort | O(n)                  | O(n^2)                   | O(n^2)                 | O(1)             |
| Selection Sort | O(n)                  | O(n^2)                   | O(n^2)                 | O(1)             |
