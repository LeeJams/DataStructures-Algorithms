## 목표

- 지금까지 학습한 정렬 알고리즘의 한계 이해
- 합병 정렬 구현
- 빠른 정렬 구현
- 기수 정렬 구현

### 한계

- 지금까지 학습한 정렬 알고리즘은 확장성이 좋지 않습니다.
- 100000개 요소의 배열에 대해 버블 정렬을 시도해 보십시오, 시간이 꽤 걸립니다.
- 대규모 어레이를 보다 신속하게 정렬할 수 있어야 함

### 빠른 정렬

- 시간 복잡성을 O(n)에서 O(n log n)로 개선할 수 있는 정렬 알고리즘 계열이 있다.
- 효율성과 단순성 사이에는 절충점이 있습니다.
- 더 효율적인 알고리즘은 훨씬 덜 단순하고 일반적으로 이해하는 데 더 오랜 시간이 걸린다.

### Merge Sort - 합병 정렬

- 합병과 정렬이라는 두 가지를 결합한 것이다.
- 0 또는 1 요소의 배열이 항상 정렬된다는 사실을 활용합니다.
- 배열을 0 또는 1 요소의 작은 배열로 분해한 다음 새로 정렬된 배열을 구성하는 방식으로 작동합니다.

- How does it work?

[ 8, 3, 5, 4, 7, 6, 1, 2 ]

[ 8, 3, 5, 4 ] [ 7, 6, 1, 2 ]

[ 8, 3 ] [ 5, 4 ] [ 1, 2 ] [ 7, 6 ]

[ 8 ] [ 3 ] [ 5 ] [ 4 ] [ 7 ] [ 6 ] [ 1 ] [ 2 ]

[ 3, 8 ] [ 4, 5 ] [ 6, 7 ] [ 1, 2 ]

[ 3, 4, 5, 8 ] [ 1, 2, 6, 7 ]

[ 1, 2, 3, 4, 5, 6, 7, 8 ]

합병 정렬을 구현하려면 먼저 정렬된 두 배열의 합병을 담당하는 함수를 구현하는 것이 유용합니다.
정렬된 두 배열이 주어지면, 이 도우미 함수는 또한 정렬되고 두 입력 배열의 모든 요소로 구성된 새로운 배열을 생성해야 한다.
이 기능은 O(n + m) 시간 및 O(n + m) 공간에서 실행되어야 하며 전달된 파라미터를 수정해서는 안 됩니다.

### Quick Sort 퀵 정렬

- 합병 정렬과 마찬가지로 0 또는 1 요소의 배열이 항상 정렬된다는 사실을 활용합니다.
- 하나의 요소("피벗")를 선택하고 정렬된 배열에서 피벗이 끝날 인덱스를 찾는 방식으로 작동합니다.
- 피벗이 적절하게 배치되면 피벗의 양쪽에 빠른 정렬을 적용할 수 있습니다.

### Radix Sort 기수 정렬

- 비교를 수행하지 않는 특별한 정렬 알고리즘
- 기수 정렬은 숫자 목록에서 작동하는 특수 정렬 알고리즘입니다.
- 이진수를 이용한다. 요소들 사이를 비교하지 않는다!
- 숫자의 크기에 대한 정보가 자릿수로 인코딩된다는 사실을 악용한다.

| Algorithms | Time Complexity(Best) | Time Complexity(Average) | Time Complexity(Worst) | Space Complexity |
| ---------- | --------------------- | ------------------------ | ---------------------- | ---------------- |
| Merge Sort | O(n log n)            | O(n log n)               | O(n log n)             | O(n)             |
| Quick Sort | O(n log n)            | O(n log n)               | O(n^2)                 | O(log n)         |
| Radix Sort | O(nk)                 | O(nk)                    | O(nk)                  | O(n + k)         |
